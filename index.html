<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scrollable Whiteboard Fix</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    overflow: hidden; /* no page scroll, only canvas container scroll */
  }
  #canvasContainer {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    overflow: auto;
    background: #eee;
    z-index: 1;
  }
  canvas {
    display: block;
    background: white;
    width: 100%;
    height: 3000px; /* Large height for scrolling */
    touch-action: none;
  }
  #toolbar {
    position: fixed;
    top: 10px; left: 10px;
    background: #fff;
    padding: 10px;
    border: 1px solid #ccc;
    z-index: 10;
  }
</style>
</head>
<body>

<div id="toolbar">
  Tool:
  <select id="toolPicker">
    <option value="pen">Pen</option>
    <option value="highlight">Highlighter</option>
    <option value="eraser">Eraser</option>
  </select>
  Color: <input type="color" id="colorPicker" value="#ff0000" />
  Size: <input type="range" id="sizePicker" min="1" max="50" value="5" />
</div>

<div id="canvasContainer">
  <canvas id="canvas"></canvas>
</div>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('canvasContainer');
  const toolPicker = document.getElementById('toolPicker');
  const colorPicker = document.getElementById('colorPicker');
  const sizePicker = document.getElementById('sizePicker');

  // Set canvas width and height to actual pixels (not CSS)
  function resizeCanvas() {
    canvas.width = container.clientWidth;
    canvas.height = 3000; // large height for scrolling/drawing
  }
  resizeCanvas();

  let drawing = false;
  let tool = 'pen';

  toolPicker.addEventListener('change', e => {
    tool = e.target.value;
  });

  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    let clientX, clientY;
    if (e.touches && e.touches.length) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    return {
      x: clientX - rect.left,
      y: clientY - rect.top
    };
  }

  function startDraw(e) {
    e.preventDefault();
    drawing = true;
    const pos = getPos(e);

    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = parseInt(sizePicker.value, 10);

    if (tool === 'pen') {
      ctx.globalAlpha = 1.0;
      ctx.strokeStyle = colorPicker.value;
    } else if (tool === 'highlight') {
      ctx.globalAlpha = 0.3; // transparent all along
      ctx.strokeStyle = colorPicker.value;
    } else if (tool === 'eraser') {
      ctx.globalAlpha = 1.0;
      ctx.strokeStyle = '#FFFFFF';
    }
  }

  function draw(e) {
    if (!drawing) return;
    e.preventDefault();
    const pos = getPos(e);
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
  }

  function stopDraw(e) {
    if (!drawing) return;
    e.preventDefault();
    drawing = false;
    ctx.closePath();
  }

  // Mouse Events
  canvas.addEventListener('mousedown', startDraw);
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('mouseup', stopDraw);
  canvas.addEventListener('mouseout', stopDraw);

  // Touch Events
  canvas.addEventListener('touchstart', startDraw);
  canvas.addEventListener('touchmove', draw);
  canvas.addEventListener('touchend', stopDraw);
  canvas.addEventListener('touchcancel', stopDraw);

  // Optional: If window resized, update canvas width (keep height fixed)
  window.addEventListener('resize', () => {
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    resizeCanvas();
    ctx.putImageData(imageData, 0, 0);
  });
</script>

</body>
</html>
