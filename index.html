<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scrollable Whiteboard Fix</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    overflow: hidden; /* no page scroll, only canvas container scroll */
  }
  #canvasContainer {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    overflow: auto;
    background: #eee;
    z-index: 1;
  }
  canvas {
    display: block;
    background: white;
    width: 100%;
    height: 3000px; /* Large height for scrolling */
    touch-action: none;
  }
  #toolbar {
    position: fixed;
    top: 10px; left: 10px;
    background: #fff;
    padding: 10px;
    border: 1px solid #ccc;
    z-index: 10;
  }
</style>
</head>
<body>

<div id="toolbar">
  Tool:
  <select id="toolPicker">
    <option value="pen">Pen</option>
    <option value="highlight">Highlighter</option>
    <option value="eraser">Eraser</option>
  </select>
  Color: <input type="color" id="colorPicker" value="#ff0000" />
  Size: <input type="range" id="sizePicker" min="1" max="50" value="5" />
</div>

<div id="canvasContainer">
  <canvas id="canvas"></canvas>
</div>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('canvasContainer');
  const toolPicker = document.getElementById('toolPicker');
  const colorPicker = document.getElementById('colorPicker');
  const sizePicker = document.getElementById('sizePicker');

  // Set canvas width and height to actual pixels (not CSS)
  function resizeCanvas() {
    canvas.width = container.clientWidth;
    canvas.height = 3000; // large height for scrolling/drawing
  }
  resizeCanvas();

  let drawing = false;
  let tool = 'pen';

  toolPicker.addEventListener('change', e => {
    tool = e.target.value;
  });

  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    let clientX, clientY;
    if (e.touches && e.touches.length) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    return {
      x: clientX - rect.left,
      y: clientY - rect.top
    };
  }

  <input type="file" id="fileInput" accept="image/*,.pdf" />
<button id="clearCanvasBtn">Clear Canvas</button>


  function startDraw(e) {
    e.preventDefault();
    drawing = true;
    const pos = getPos(e);

    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = parseInt(sizePicker.value, 10);

    if (tool === 'pen') {
      ctx.globalAlpha = 1.0;
      ctx.strokeStyle = colorPicker.value;
    } else if (tool === 'highlight') {
      ctx.globalAlpha = 0.3; // transparent all along
      ctx.strokeStyle = colorPicker.value;
    } else if (tool === 'eraser') {
      ctx.globalAlpha = 1.0;
      ctx.strokeStyle = '#FFFFFF';
    }
  }

  function draw(e) {
    if (!drawing) return;
    e.preventDefault();
    const pos = getPos(e);
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
  }

  function stopDraw(e) {
    if (!drawing) return;
    e.preventDefault();
    drawing = false;
    ctx.closePath();
  }

const fileInput = document.getElementById('fileInput');
const clearCanvasBtn = document.getElementById('clearCanvasBtn');

fileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();

  if (file.type.startsWith('image/')) {
    reader.onload = function(event) {
      const img = new Image();
      img.onload = () => {
        // Clear canvas before drawing image or keep existing content if you want
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Draw image at top-left corner or scale as needed
        ctx.drawImage(img, 0, 0, canvas.width, img.height * (canvas.width / img.width));
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  }
  
  // For PDFs, more complex; ask if you want help with that
});

clearCanvasBtn.addEventListener('click', () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
});

  
  // Mouse Events
  canvas.addEventListener('mousedown', startDraw);
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('mouseup', stopDraw);
  canvas.addEventListener('mouseout', stopDraw);

  // Touch Events
  canvas.addEventListener('touchstart', startDraw);
  canvas.addEventListener('touchmove', draw);
  canvas.addEventListener('touchend', stopDraw);
  canvas.addEventListener('touchcancel', stopDraw);

  // Optional: If window resized, update canvas width (keep height fixed)
  window.addEventListener('resize', () => {
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    resizeCanvas();
    ctx.putImageData(imageData, 0, 0);
  });

  <button id="lassoBtn">Lasso Erase</button>
const lassoBtn = document.getElementById('lassoBtn');
lassoBtn.addEventListener('click', startLasso);


  let lassoPoints = [];
let lassoActive = false;

function drawLassoLine() {
  if (lassoPoints.length === 0) return;
  ctx.save();
  ctx.strokeStyle = 'blue';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
  for (let i = 1; i < lassoPoints.length; i++) {
    ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
  }
  ctx.stroke();
  ctx.restore();
}

function startLasso() {
  lassoPoints = [];
  lassoActive = true;
  alert('Click points on canvas to draw lasso. Double click to finish and erase inside.');
}

// On canvas click handler for lasso:
canvas.addEventListener('click', (e) => {
  if (!lassoActive) return;
  const pos = getPos(e);
  lassoPoints.push(pos);
  redrawCanvas();
  drawLassoLine();
});

// On canvas double click to finish lasso:
canvas.addEventListener('dblclick', (e) => {
  if (!lassoActive) return;
  if (lassoPoints.length < 3) {
    alert('Need at least 3 points to form a polygon');
    return;
  }
  lassoActive = false;

  // Create a path and erase inside polygon
  ctx.save();
  ctx.globalCompositeOperation = 'destination-out'; // erase mode

  ctx.beginPath();
  ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
  for (let i = 1; i < lassoPoints.length; i++) {
    ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
  }
  ctx.closePath();
  ctx.fill();  // this erases inside polygon

  ctx.restore();

  lassoPoints = [];
  redrawCanvas();
});

function redrawCanvas() {
  // If you have a background image or saved drawing, redraw it here
  // For now just clear:
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // TODO: redraw your image or strokes here if you saved them

  // If lasso active, draw lasso lines again
  if (lassoActive) {
    drawLassoLine();
  }
}
  
</script>

</body>
</html>
