<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Interactive Whiteboard</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #toolbar {
      display: flex;
      gap: 10px;
      padding: 10px;
      background: #eee;
      align-items: center;
    }
    #toolbar button, #toolbar input[type=color] {
      cursor: pointer;
      font-size: 16px;
    }
    #canvas-container {
      position: relative;
      height: calc(100% - 50px);
      overflow: auto;
      background: #fff;
    }
    canvas {
      display: block;
      background: white;
      touch-action: none;
    }
    .icon {
      font-size: 20px;
      background: none;
      border: none;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="draw" title="Draw">‚úèÔ∏è</button>
    <button id="highlight" title="Highlight">üñçÔ∏è</button>
    <button id="eraser" title="Lasso Erase">‚≠ï</button>
    <input type="color" id="colorPicker" value="#000000">
    <button id="undo" title="Undo">‚Ü©Ô∏è</button>
    <button id="redo" title="Redo">‚Ü™Ô∏è</button>
    <input type="file" id="uploadFile" accept="image/*,.pdf">
    <button id="fullscreen" title="Fullscreen">üî≤</button>
  </div>

  <div id="canvas-container">
    <canvas id="whiteboard" width="1200" height="1600"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('whiteboard');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const colorPicker = document.getElementById('colorPicker');
    let mode = 'draw';
    let isDrawing = false;
    let lastPoint = null;
    let strokes = [];
    let undoneStrokes = [];
    let lassoPoints = [];
    let backgroundImage = null;

    function setMode(newMode) {
      mode = newMode;
      if (mode !== 'eraser') lassoPoints = [];
    }

    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.clientX || (e.touches && e.touches[0].clientX);
      const clientY = e.clientY || (e.touches && e.touches[0].clientY);
      return {
        x: (clientX - rect.left) * (canvas.width / rect.width),
        y: (clientY - rect.top) * (canvas.height / rect.height)
      };
    }

    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (backgroundImage) ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
      for (const stroke of strokes) {
        ctx.save();
        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = stroke.width;
        ctx.globalAlpha = stroke.alpha;
        ctx.beginPath();
        for (let i = 0; i < stroke.points.length; i++) {
          const p = stroke.points[i];
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
        ctx.restore();
      }
    }

    function addStroke(points, color, width, alpha) {
      strokes.push({ points, color, width, alpha });
      undoneStrokes = [];
      redrawCanvas();
    }

    function undo() {
      if (strokes.length > 0) {
        undoneStrokes.push(strokes.pop());
        redrawCanvas();
      }
    }

    function redo() {
      if (undoneStrokes.length > 0) {
        strokes.push(undoneStrokes.pop());
        redrawCanvas();
      }
    }

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('mouseleave', endDraw);
    canvas.addEventListener('touchstart', (e) => startDraw(e), { passive: false });
    canvas.addEventListener('touchmove', (e) => draw(e), { passive: false });
    canvas.addEventListener('touchend', endDraw);

    function startDraw(e) {
      e.preventDefault();
      if (mode === 'eraser') {
        const pos = getPos(e);
        lassoPoints = [pos];
        return;
      }
      isDrawing = true;
      lastPoint = getPos(e);
      currentStroke = [lastPoint];
    }

    function draw(e) {
      e.preventDefault();
      if (!isDrawing && mode !== 'eraser') return;
      const pos = getPos(e);

      if (mode === 'eraser') {
        lassoPoints.push(pos);
        redrawCanvas();
        ctx.save();
        ctx.strokeStyle = 'blue';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
        for (let i = 1; i < lassoPoints.length; i++) ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
        ctx.stroke();
        ctx.restore();
        return;
      }

      currentStroke.push(pos);
      ctx.save();
      ctx.strokeStyle = colorPicker.value;
      ctx.lineWidth = mode === 'highlight' ? 20 : 2;
      ctx.globalAlpha = mode === 'highlight' ? 0.3 : 1.0;
      ctx.beginPath();
      ctx.moveTo(lastPoint.x, lastPoint.y);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      ctx.restore();
      lastPoint = pos;
    }

    function endDraw() {
      if (!isDrawing) return;
      isDrawing = false;
      if (mode !== 'eraser') {
        addStroke(currentStroke, colorPicker.value, mode === 'highlight' ? 20 : 2, mode === 'highlight' ? 0.3 : 1.0);
      } else {
        eraseInsideLasso();
        lassoPoints = [];
      }
    }

    function eraseInsideLasso() {
      function pointInPolygon(point, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const xi = polygon[i].x, yi = polygon[i].y;
          const xj = polygon[j].x, yj = polygon[j].y;
          const intersect = ((yi > point.y) !== (yj > point.y)) &&
                            (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      strokes = strokes.filter(stroke => !stroke.points.some(p => pointInPolygon(p, lassoPoints)));
      redrawCanvas();
    }

    document.getElementById('draw').onclick = () => setMode('draw');
    document.getElementById('highlight').onclick = () => setMode('highlight');
    document.getElementById('eraser').onclick = () => setMode('eraser');
    document.getElementById('undo').onclick = () => undo();
    document.getElementById('redo').onclick = () => redo();

    document.getElementById('uploadFile').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      if (file.type === 'application/pdf') {
        alert('PDF support not yet implemented'); // Optional: Use PDF.js
      } else if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            backgroundImage = img;
            redrawCanvas();
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }
    });

    document.getElementById('fullscreen').onclick = () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    };
  </script>
</body>
</html>
